using System;

namespace CSharpLeetCode
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }



            /*
                孩子们的游戏(圆圈中最后剩下的数) 相似的企业真题
                时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32M，其他语言64M 热度指数：258307
                本题知识点： 链表 数学
                 算法知识视频讲解
                题目描述
                每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)
                如果没有小朋友，请返回-1


    》》可以这样理解这个方法：
    》》当有n个人的时候，他们的编号依次是0、1、2、3、4、………、n-1。假设最后编号为x(n)的人会留下来。
    》》因为数到m的那个人会出列，那么此轮中编号为(m-1)%n的人会出列，编号为(m+0)%n的人将做为下一轮编号为0的人，此轮编号为(m+i)%n的人将做为下一轮编号为i的人…
    》》因此当有n-1个人的时候，编号为i的人对应着上一轮编号为(m+i)%n的人。假设此轮编号为x(n-1)的人最终会留下来。因为编号为x(n-1)的人肯定对应着上一轮的x(n)，所以有x(n)=(m+x(n-1))%n。
    》》有了这个递推公式，那我们就可以一直递推到x(2)=(m+x(1))%2，而x(1)=0。
    》》所以我们可以这么来写这个函数:
    》》j = 0
    》》for i 从 2 到 n：
    》》》》j = （m+j）%i
    》》最终第j个人会留下来(如果从1开始编号就是第j+1个人最终会留下来)。

                》》比如当m=5,n=5时。这5个人的编号依次是：0、1、2、3、4。第一轮中报数m的人是4号，他的编号可以通过(m-1)%n算出来。
                》》第二轮中将以第一轮编号为(m%n=)0的人做为新的编号为0的人。此轮中编号为0、1、2、3的人对应着上一轮中编号为0、1、2、3的人。
                》》关键点来了，假设最后留下来的人的在第一轮中编号为x(5),在第二轮中编号为x(4)。那么由两轮的对应关系可以得到 x(5) = (m+x(4))%n。
                》》也就是说x(5) =(5+x(4))%5
                》》同样有x(4) =(5+x(3))%4
                》》……得到递推关系式：x(i) = (m+x(i-1))%i
                》》那么要求x(i)的话必须要知道x(i-1)。而已经知道当有1个人的话留下来话，这个人的编号肯定是0，就是x(1) = 0。
                》》现在先让j=0,
                》》然后让i 从2遍历到n
                每一次遍历给j赋一个递推的新值：
                》》》》j=(m+j)%i
                》》循环完后j就是有n个人时最后会留下来的人的编号。答案就是j了
                》》如果要编号为1开始的话就输出j+1
             */
        public int LastRemaining(int n, int m)
        {
            if (n == 1) return 0;
            
            return (LastRemaining(n - 1, m) + m) % n;
        }
    }


}
